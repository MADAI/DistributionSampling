#!/usr/bin/env python2

"""
    This is a simple GUI for the MADAI emulator.
    It provides an easy interface between the users and the MADAI emulator
    and clear visual information for the comparison between the emulator
    results and the experimental data.
    It calls the built in program madai_emulate to get results from the
    emulator.
"""

import subprocess
from Tkinter import *
import sys
from os import path


class HelloWorld:
    def __init__(self, parent, stat_directory):

        # initialize the emulator
        self.emulator = subprocess.Popen(
            ["madai_emulate", stat_directory], stdin=subprocess.PIPE,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        self.parameters = {}            # holds all the parameters
        self.parameter_range = {}       # holds the ranges of the parameters
        self.parameter_name_list = []   # records the order of the parameters
        self.observables_list = {}      # holds all the observables
        self.observable_name_list = []  # records the order of the observables
        self.number_of_lines_for_covariance_matrix = 0
        self.result_list = []

        # read the header
        self.read_in_header()

        """Build the GUI"""
        self.master = parent  # store the parent
        title_frame = Frame(parent)   # frame for all class widgets
        title_frame.pack(side='top')  # pack frame in parent's window

        # create frame to hold the first widget row:
        header_frame = Frame(title_frame)
        # this frame (row) is packed from top to bottom:
        header_frame.pack(side='top')
        # create label in the frame:
        font = 'times 48 bold'
        title_text = 'GUI for MADAI emulator'
        header_text = Label(header_frame, text=title_text, fg='blue', font=font)
        header_text.pack(side='top', pady=20)

        middle_frame = Frame(title_frame)
        middle_frame.pack(side='top', padx=2, pady=2)

        # place all the sliders in a left frame:
        slider_frame = Frame(middle_frame)
        slider_frame.pack(side='left', padx=2, pady=2)

        self.slider_widget_list = {}
        for parameter_name in self.parameter_name_list:
            parameter_min = self.parameter_range[parameter_name][0]
            parameter_max = self.parameter_range[parameter_name][1]
            parameter_default = (parameter_min + parameter_max)/2.
            self.parameters[parameter_name] = DoubleVar()
            self.parameters[parameter_name].set(parameter_default)
            self.slider_widget_list[parameter_name] = self.slider(
                slider_frame, self.parameters[parameter_name], parameter_min,
                parameter_max, parameter_name)

        # place the textentry widgets and the buttons in a frame
        # to the right of slider_frame:
        text_entry_frame = Frame(middle_frame)
        text_entry_frame.pack(side='left', anchor='n', padx=2, pady=2)

        # use a separate frame and the grid geometry manager to
        # pack the labels and entries in a table fashion (enables
        # nice alignment):
        entry_frame = Frame(text_entry_frame)
        entry_frame.pack(side='top', pady=22, padx=12)
        self.row_counter = 0

        self.text_entry_widget_list = {}
        for parameter_name in self.parameter_name_list:
            text_entry_widget = self.textentry(
                entry_frame, self.parameters[parameter_name], parameter_name)
            text_entry_widget.bind('<Return>',
                lambda event: self.slider_widget_list[parameter_name].configure(
                    to=self.parameters[parameter_name].get())
            )
            self.text_entry_widget_list[parameter_name] = text_entry_widget

        # add some space (empty label):
        Label(text_entry_frame, text='').pack(side='top', pady=5)

        # add compute button:
        self.sim = Button(text_entry_frame, text='Compute',
                          width=8, command=self.compute)
        self.sim.pack(side='top', pady=5)

        # put the results to the right of text entry widgets
        results_frame = Frame(middle_frame)
        results_frame.pack(side='left', anchor='n', padx=2, pady=2)
        results_title_frame = Frame(results_frame)
        results_title_frame.pack(side='top', anchor='n', padx=1, pady=1)
        results_title_text = Label(
            results_title_frame, text='results', fg='black',
            font='times 30 bold')
        results_title_text.pack(side='top', pady=5)

        # read in experimental observables
        observables_file = open(
            path.join(stat_directory, 'experimental_results.dat'), 'r')
        for observable_line in observables_file:
            temp_line = observable_line.split(' ')
            observable_name = temp_line[0]
            self.observable_name_list.append(observable_name)
            observables_value = temp_line[1]
            observables_value_error = temp_line[2]
            self.observables_list[observable_name] = (
                observables_value, observables_value_error)
            self.result_list.append(StringVar())
        self.compute()

        results_show_frame = Frame(results_frame)
        results_show_frame.pack(side='top', anchor='n', padx=2, pady=2)

        # print observables names
        results_name_frame = Frame(results_show_frame)
        results_name_frame.pack(side='left', anchor='n', padx=2, pady=2)
        font_format = 'times 20 bold'
        observable_name = Label(results_name_frame, text='name', fg='black',
                                font=font_format)
        observable_name.pack(side='top', pady=1)
        for observable_name in self.observable_name_list:
            observable_text = Label(results_name_frame, text=observable_name,
                                    fg='red', font=font_format)
            observable_text.pack(side='top', pady=1)

        # print theory results
        results_theory_frame = Frame(results_show_frame)
        results_theory_frame.pack(side='left', anchor='n', padx=2, pady=2)
        font_format = 'times 20'
        observable_name = Label(results_theory_frame, text='theory', fg='black',
                                font=(font_format + ' bold'))
        observable_name.pack(side='top', pady=1)
        for i in range(len(self.observable_name_list)):
            observable_text = Label(
                results_theory_frame, textvariable=self.result_list[i],
                fg='black', font=font_format)
            observable_text.bind('<Return>', self.compute())
            observable_text.pack(side='top', pady=1)

        # print experimental results
        results_exp_frame = Frame(results_show_frame)
        results_exp_frame.pack(side='left', anchor='n', padx=2, pady=2)
        font_format = 'times 20'
        observable_name = Label(results_exp_frame, text='exp.', fg='black',
                                font=(font_format + ' bold'))
        observable_name.pack(side='top', pady=1)
        for observable_name in self.observable_name_list:
            observables_value = float(self.observables_list[observable_name][0])
            observables_value_error = float(
                self.observables_list[observable_name][1])
            obs_min = observables_value - observables_value_error
            obs_max = observables_value + observables_value_error
            observable_text = Label(
                results_exp_frame, text='(%g, %g)' % (obs_min, obs_max),
                fg='black', font=font_format)
            observable_text.pack(side='top', pady=1)

    def read_in_header(self, ):
        """
            read in header information for the emulator and initialize the
            parameter and observables dictionaries
        """
        self.emulator.stdout.readline()  # skip the line for version information

        #  read in parameters information
        number_of_parameters = int(self.emulator.stdout.readline().split()[1])
        for i in range(number_of_parameters):
            line_list = self.emulator.stdout.readline().split()
            parameter_name = line_list[0]
            self.parameter_name_list.append(parameter_name)
            parameter_min = float(line_list[2])
            parameter_max = float(line_list[3])
            self.parameter_range[parameter_name] = (
                parameter_min, parameter_max)
            self.parameters[parameter_name] = (parameter_min + parameter_max)/2.

        # skip observables information
        number_of_observables = int(self.emulator.stdout.readline().split()[1])
        for i in range(number_of_observables):
            self.emulator.stdout.readline()

        # read in number of lines for covariance matrix
        self.number_of_lines_for_covariance_matrix = int(
            self.emulator.stdout.readline().split()[2])

        self.emulator.stdout.readline()  # skip the line "END_OF_HEADER"

    def compute(self,):
        """
            This function call the MADAI emulator and return the results
        """
        # prepare the input stream for the emulator
        parameter_stream = ''
        for parameter_name in self.parameter_name_list:
            parameter_stream = (
                parameter_stream + ' '
                + str(self.parameters[parameter_name].get()) + '\n')

        # call the emulator
        self.emulator.stdin.write(parameter_stream)

        # retrieve the results from stdout
        for i in range(len(self.observable_name_list)):
            line = self.emulator.stdout.readline()
            self.result_list[i].set(str('%g' % float(line)))

        # skip the covariant matrix
        for i in range(self.number_of_lines_for_covariance_matrix):
            self.emulator.stdout.readline()

    def textentry(self, parent, variable, label):
        """Make a textentry field tied to variable."""
        # pack a label and entry horizontally in a frame:
        l = Label(parent, text=label)
        l.grid(column=0, row=self.row_counter, sticky='w')
        widget = Entry(parent, textvariable=variable, width=8)
        widget.grid(column=1, row=self.row_counter)
        #widget.grid(column=1, sticky='w')
        self.row_counter += 1
        return widget

    def slider(self, parent, variable, low, high, label):
        """Make a slider [low,high] tied to variable."""
        widget = Scale(parent, orient='horizontal',
                       from_=low, to=high,  # range of slider
                       #  tickmarks on the slider "axis":
                       tickinterval=(high-low),
                       # the steps of the counter above the slider:
                       resolution=(high-low)/5000.0,
                       label=label,    # label printed above the slider
                       length=300,     # length of slider in pixels
                       variable=variable)  # slider value is tied to variable
        widget.pack(side='top')
        return widget


def create_GUI_for_emulator(directory_path):
    root = Tk() # root (main) window
    hello = HelloWorld(root, directory_path)
    root.mainloop()

if __name__ == '__main__':
    if len(sys.argv) != 2:
        print 'Usage: ' + sys.argv[0] + '/stats/directory/'
        exit()
    stat_directory = path.abspath(sys.argv[1])
    create_GUI_for_emulator(stat_directory)
